<?php

require_once 'PHPUnit/Framework.php';

require_once dirname(__FILE__) . '/../Benchmark/Benchmark.php';

/**
 * Test class for Result.
 * Generated by PHPUnit on 2010-08-24 at 13:21:46.
 */
class ResultTest extends PHPUnit_Framework_TestCase {

    /**
     * @var Result
     */
    protected $bmresult;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {
        $this->bmresult = new Result;
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {

    }

    public function testSetMethodResult() {
        $result = array(1, 'string', array(1,true));

        $this->bmresult->setMethodResult($result);
        self::assertSame($result, $this->bmresult->getMethodResult());
    }

    public function testGetMethodResult_DefaultValue() {
        self::assertNull($this->bmresult->getMethodResult());
    }

    public function testSetStartTime_InvalidArguments() {

        $valid_time = time();
        $this->bmresult->setStartTime($valid_time);

        $this->bmresult->setStartTime(-1);
        $this->bmresult->setStartTime(0);
        $this->bmresult->setStartTime(null);
        $this->bmresult->setStartTime('string');

        self::assertSame($valid_time, $this->bmresult->getStartTime(),
                'invalid values must have not been stored');
    }

    public function testSetStartTime_LaterThanEndTime() {
        $end_time = time();
        $start_time = $end_time + 10;

        $this->bmresult->setEndTime($end_time);
        $this->bmresult->setStartTime($start_time);

        self::assertSame($start_time, $this->bmresult->getEndTime());
        self::assertSame($end_time, $this->bmresult->getStartTime());
    }

    public function testGetStartTime_DefaultValue() {
        self::assertNull($this->bmresult->getStartTime(),
                'start time must not be set');
    }

    public function testSetEndTime_InvalidArguments() {
        $valid_time = time();
        $this->bmresult->setEndTime($valid_time);

        $this->bmresult->setEndTime(-1);
        $this->bmresult->setEndTime(0);
        $this->bmresult->setEndTime(null);
        $this->bmresult->setEndTime('string');

        self::assertSame($valid_time, $this->bmresult->getEndTime(),
                'invalid values must have not been stored');

    }

    public function testSetEndTime_EarlierThanStartTime() {
        $start_time = time();
        $end_time = $start_time - 10;

        $this->bmresult->setStartTime($start_time);
        $this->bmresult->setEndTime($end_time);

        self::assertSame($start_time, $this->bmresult->getEndTime());
        self::assertSame($end_time, $this->bmresult->getStartTime());
    }

    public function testGetTimeElapsed_StartAndEndIsSet() {

        $time_elapsed = 10;

        $start_time = time();
        $end_time = $start_time + $time_elapsed;

        $this->bmresult->setStartTime($start_time);
        $this->bmresult->setEndTime($end_time);
        self::assertSame($time_elapsed, $this->bmresult->getTimeElapsed(),
                'time elapsed must be equal to calculated one');
    }

    public function testGetTimeElapsed_StillRunning() {

        $start_time = microtime(true);
        $this->bmresult->setStartTime($start_time);

        self::assertGreaterThan(0, $this->bmresult->getTimeElapsed(),
                'time should elapse by now');
    }

    public function testGetTimeElapsed_NotRunning() {
        self::assertFalse($this->bmresult->getTimeElapsed());
    }
}